"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectDocCommentIncludes = exports.printTypeWarning = void 0;
const typescript_1 = require("@tsd/typescript");
const utils_1 = require("../../utils");
/**
 * Default formatting flags set by TS plus the {@link TypeFormatFlags.NoTruncation NoTruncation} flag.
 *
 * @see {@link https://github.dev/microsoft/TypeScript/blob/b975dfa1027d1f3073fa7cbe6f7045bf4c882785/src/compiler/checker.ts#L4717 TypeChecker.typeToString}
 */
const typeToStringFormatFlags = typescript_1.TypeFormatFlags.AllowUniqueESSymbolType |
    typescript_1.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope |
    typescript_1.TypeFormatFlags.NoTruncation;
/**
 * Prints the type of the argument of the assertion as a warning.
 *
 * @param checker - The TypeScript type checker.
 * @param nodes - The `printType` AST nodes.
 * @return List of warning diagnostics containing the type of the first argument.
 */
const printTypeWarning = (checker, nodes) => {
    const diagnostics = [];
    if (!nodes) {
        return diagnostics;
    }
    for (const node of nodes) {
        const argumentType = checker.getTypeAtLocation(node.arguments[0]);
        const argumentExpression = node.arguments[0].getText();
        const typeString = checker.typeToString(argumentType, node, typeToStringFormatFlags);
        diagnostics.push((0, utils_1.makeDiagnostic)(node, `Type for expression \`${argumentExpression}\` is: \`${typeString}\``, 'warning'));
    }
    return diagnostics;
};
exports.printTypeWarning = printTypeWarning;
/**
 * Asserts that the documentation comment for the argument of the assertion
 * includes the string literal generic type of the assertion.
 *
 * @param checker - The TypeScript type checker.
 * @param nodes - The `expectDocCommentIncludes` AST nodes.
 * @return List of diagnostics.
 */
const expectDocCommentIncludes = (checker, nodes) => {
    var _a;
    const diagnostics = [];
    if (!nodes) {
        return diagnostics;
    }
    for (const node of nodes) {
        const expression = (_a = utils_1.tsutils.expressionToString(checker, node.arguments[0])) !== null && _a !== void 0 ? _a : '?';
        if (!node.typeArguments) {
            diagnostics.push((0, utils_1.makeDiagnostic)(node, `Expected documentation comment for expression \`${expression}\` not specified.`));
            continue;
        }
        const maybeExpectedDocComment = checker.getTypeFromTypeNode(node.typeArguments[0]);
        if (!maybeExpectedDocComment.isStringLiteral()) {
            diagnostics.push((0, utils_1.makeDiagnostic)(node, `Expected documentation comment for expression \`${expression}\` should be a string literal.`));
            continue;
        }
        const expectedDocComment = maybeExpectedDocComment.value;
        const docComment = utils_1.tsutils.resolveDocComment(checker, node.arguments[0]);
        if (!docComment) {
            diagnostics.push((0, utils_1.makeDiagnostic)(node, `Documentation comment for expression \`${expression}\` not found.`));
            continue;
        }
        if (docComment.includes(expectedDocComment)) {
            // Do nothing
            continue;
        }
        diagnostics.push((0, utils_1.makeDiagnosticWithDiff)({
            message: `Documentation comment \`{receivedType}\` for expression \`${expression}\` does not include expected \`{expectedType}\`.`,
            expectedType: expectedDocComment,
            receivedType: docComment,
            checker,
            node,
        }));
    }
    return diagnostics;
};
exports.expectDocCommentIncludes = expectDocCommentIncludes;
