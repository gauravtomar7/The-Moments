"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("@tsd/typescript");
const typeToStringFormatFlags = typescript_1.TypeFormatFlags.NoTruncation |
    typescript_1.TypeFormatFlags.WriteArrayAsGenericType |
    typescript_1.TypeFormatFlags.UseStructuralFallback |
    typescript_1.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope |
    typescript_1.TypeFormatFlags.NoTypeReduction |
    typescript_1.TypeFormatFlags.AllowUniqueESSymbolType |
    typescript_1.TypeFormatFlags.InArrayType |
    typescript_1.TypeFormatFlags.InElementType |
    typescript_1.TypeFormatFlags.InFirstTypeArgument |
    typescript_1.TypeFormatFlags.InTypeAlias;
/**
 * Create a diagnostic with type error diffs from the given `options`, see {@link DiagnosticWithDiffOptions}.
 *
 * @param options - Options for creating the diagnostic.
 * @returns Diagnostic with diffs
 */
exports.default = (options) => {
    var _a;
    const { checker, node, expectedType, receivedType } = options;
    const position = node.getSourceFile().getLineAndCharacterOfPosition(node.getStart());
    const message = options.message
        .replace('{expectedType}', typeof expectedType === 'string' ? expectedType : checker.typeToString(expectedType))
        .replace('{receivedType}', typeof receivedType === 'string' ? receivedType : checker.typeToString(receivedType));
    return {
        fileName: node.getSourceFile().fileName,
        message,
        severity: (_a = options.severity) !== null && _a !== void 0 ? _a : 'error',
        line: position.line + 1,
        column: position.character,
        diff: {
            expected: typeof expectedType === 'string' ? expectedType : checker.typeToString(expectedType, node, typeToStringFormatFlags),
            received: typeof receivedType === 'string' ? receivedType : checker.typeToString(receivedType, node, typeToStringFormatFlags)
        }
    };
};
